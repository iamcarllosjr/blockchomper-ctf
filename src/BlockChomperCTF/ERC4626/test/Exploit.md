# Uma vulnerabilidade no código está relacionada à ordem das operações na função deposit. Vamos analisar o problema :
```solidity
function deposit(uint256 assets, address receiver) public virtual override returns (uint256 shares) {
   uint256 supply = totalSupply();
   shares = supply == 0 ? assets : (assets * supply) / totalAssets();
   _mint(receiver, shares);           // <-- Primeiro minta as shares
   _asset.safeTransferFrom(msg.sender, address(this), assets); // <-- Depois transfere os assets
   emit Deposit(msg.sender, receiver, assets, shares);
```

## O problema ocorre porque :
  1. O cálculo de shares usa `totalAssets()` para determinar quantas shares devem ser mintadas.
  2. `totalAssets()` verifica o saldo atual de tokens no vault.

## Isto permite um ataque onde :
  1. Um atacante pode fazer um depósito inicial pequeno (ex: 1 token) para receber 1 share
  2. Em seguida, ele pode transferir uma grande quantidade de tokens diretamente para o vault (usando transfer ou donateAssets).
  3. Quando outra pessoa tentar fazer um depósito, o cálculo `(assets * supply) / totalAssets()` resultará em muito menos shares do que deveria, pois :
     - `totalAssets()` já inclui os tokens "doados".

## A ordem correta seria :
  1. Calcular as shares.
  2. Transferir os assets.
  3. Só então mintar as shares.

## Este é um exemplo clássico de vulnerabilidade de ordem de operações (transaction ordering) em DeFi, similar ao ataque de "donation attack" em alguns pools de liquidez.

## O ataque também poderia ocorrer da seguinte maneira :
  - Um usuário qualquer pode tentar depositar no vault, ao observar a chamada da função, um usuário malicioso pode depositar 1 eth antes da vitima, e enviar através da função `donate()` outra quantia de tokens (1000 de exemplo).
  - Após a "doação", o vault tem 1001 tokens mas apenas 1 share em circulação
  -  Quando a vítima deposita, o cálculo `(assets * supply) / totalAssets()` resulta em `(100 * 1) / 1001` ≈ 0.1 shares
  - O atacante pode então resgatar sua única share por aproximadamente 1000 tokens, efetivamente roubando valor dos outros depositantes.

# Exploit na função `withdraw()`
   1. Ordem das Operações Incorreta: Similar ao problema na função deposit, a ordem das operações não é ideal. O contrato primeiro calcula as shares e depois faz a transferência dos assets, o que pode levar a problemas de precisão e possível manipulação.
   2. Problema de Arredondamento: A função convertToShares usa arredondamento para baixo (Math.Rounding.Floor), mas quando calculamos primeiro as shares e depois fazemos a transferência dos assets, podemos ter uma situação onde:
    - O usuário solicita retirar X assets
    - O cálculo de shares arredonda para baixo
    - Quando essas shares são queimadas, o usuário recebe menos assets do que solicitou inicialmente
   3. Verificação de Saldo Inconsistente: A função verifica o saldo de shares do owner_ após calcular a conversão, mas seria mais seguro verificar primeiro se há assets suficientes no vault.

## Uma implementação mais segura seria :
```solidity
function withdraw(uint256 assets, address receiver, address owner_)
   public
   virtual
   override
   returns (uint256 shares)

   // Verificar se o vault tem assets suficientes primeiro
   require(assets <= totalAssets(), "Insufficient assets in vault");
   
   // Calcular shares antes de qualquer operação
   shares = convertToShares(assets);
   
   if (msg.sender != owner_) {
       uint256 maxAssets = convertToAssets(allowance(owner_, msg.sender));
       require(assets <= maxAssets, "Withdraw amount exceeds allowance");
       _spendAllowance(owner_, msg.sender, shares);
   }
    require(shares <= balanceOf(owner_), "Withdraw amount exceeds balance");
    // Transferir os assets antes de queimar as shares
   _asset.safeTransfer(receiver, assets);
   _burn(owner_, shares);
    emit Withdraw(msg.sender, receiver, owner_, assets, shares);
   return shares;
```

## As principais correções incluem :
  1. Verificação inicial de saldo do vault
  2. Inversão da ordem de transferência e queima (seguindo o padrão "checks-effects-interactions")
  3. Uso consistente das shares calculadas para a allowance